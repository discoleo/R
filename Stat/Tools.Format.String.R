########################
###
### Leonard Mada
### [the one and only]
###
### Tools: Packages & CRAN
###
### draft v.0.2c


# this file:
# source("Tools.Format.String.R");


##########################

# Note:
# - a 1-pass exact algorithm is possible (and not too complicated),
#   but it requires sequential processing of each row;
format.lines = function(x, w=80, justify="left", NL.rm=TRUE, indent=c("   ", ""), iter=2) {
	if(NL.rm) {
		for(nc in seq(ncol(x))) {
			x[, nc] = gsub("[ \t]*+[\n\r]++[ \t\r]*+", " ", x[, nc], perl=TRUE);
		}
	}
	# Detect Long Lines
	n  = sapply(seq(ncol(x)), function(nc) nchar(x[,nc]));
	nL = matrix(n, ncol=ncol(x));
	# Indentation:
	indent = rep.indent(indent, ncol(x));
	addCh  = nchar.L1.indent(indent);
	nL = nL + addCh; # 1-st line gets always indented;
	if(length(w) == 1) {
		nL = 1 + ((nL - 1) %/% w);
		w = rep(w, ncol(x));
	} else {
		nL = sapply(seq(ncol(x)), function(nc) 1 + ((nL[,nc] - 1) %/% w[nc]));
	}
	if(is.null(dim(nL))) nL = matrix(nL, ncol=ncol(x));
	maxL = apply(nL, 1, max, na.rm=TRUE);
	nL[is.na(nL)] = 1;
	csm = cumsum(c(1, maxL));
	txt = matrix("", nrow=tail(csm, 1), ncol=ncol(x));
	for(nc in seq(ncol(x))) {
		indent0 = if(is.list(indent)) indent[[nc]] else indent;
		for(nr in seq(nrow(x))) {
			nL0 = nL[nr, nc];
			txt[seq(csm[nr], length.out=nL0), nc] =
				split.N.line(x[nr, nc], w=w[nc], nL=nL0, indent=indent0);
		}
	}
	# Better formatting: 2nd pass;
	if(iter >= 2) {
		indent0 = extract.L2.indent(indent);
		while(iter > 1) {
			iter = iter - 1;
			# re-format only last lines
			idLast  = tail(csm, -1) - 1; # ERR: fails for iter > 2
			idLast1 = idLast[maxL > 1]; # multiple lines
			if(length(idLast1) == 0) next;
			txt = split.some.lines(txt, idLast1, w=w, indent=indent0);
			nL.new = attr(txt, "nLines");
			if( ! is.null(nL.new)) {
				id = match(nL.new[[1]], idLast);
				maxL[id] = maxL[id] + nL.new[[2]] - 1; # avoid double count;
			}
		}
	}
	txt = apply(txt, 2, format, justify=justify);
	attr(txt, "nLines") = maxL;
	return(txt);
}
# split only some of the lines: idL;
split.some.lines = function(txt, idL, w=80, indent="") {
	if(length(idL) == 0) {
		attr(txt, "nLines") = NULL;
		return(txt);
	}
	n = sapply(seq(ncol(txt)), function(nc) nchar(txt[idL, nc]));
	nL = matrix(n, ncol=ncol(txt));
	nL = sapply(seq(ncol(txt)), function(nc) 1 + ((nL[,nc] - 1) %/% w[nc]));
	nL = matrix(nL, ncol=ncol(txt));
	# Max No of Lines (generated by splitting):
	maxL = apply(nL, 1, max, na.rm=TRUE);
	isML = (maxL > 1);
	idL = idL[isML]; len = length(idL);
	if(len == 0) return(txt); # NO formatting needed;
	# filter out Lines to split:
	nL = nL[isML, , drop=FALSE]; maxL = maxL[isML];
	nL[is.na(nL)] = 0;
	if(ncol(txt) > 1 && length(indent) == 1) indent = rep(indent, len);
	dNRow = cumsum(maxL - 1);
	# idLine: Start & End
	idS = idL + c(0, head(dNRow, -1)); idE = idL + dNRow + 1;
	# Result:
	tmp = matrix("", nrow = nrow(txt) + tail(dNRow, 1), ncol=ncol(txt));
	# update matrix
	for(nc in seq(ncol(tmp))) {
		nr0 = 1; nr0_tmp = 1;
		for(idr in seq_along(idL)) {
			nr = idL[idr]; nr_tmp = idS[idr];
			if(nr > nr0) {
				tmp[seq(nr0_tmp, nr_tmp - 1), nc] = txt[seq(nr0, nr - 1), nc];
			}
			nL0 = nL[idr, nc];
			tmp[seq(nr_tmp, length.out = nL0), nc] =
				split.N.line(txt[nr, nc], w=w[nc], nL=nL0, indent=indent[[nc]]);
			nr0 = nr + 1; nr0_tmp = idE[idr];
		}
		if(nrow(tmp) >= nr0_tmp) {
			tmp[seq(nr0_tmp, nrow(tmp)), nc] = txt[seq(nr0, nrow(txt)), nc];
		}
	}
	attr(tmp, "nLines") = list(idL, maxL);
	return(tmp);
}

# TODO:
# - explore also package gridtext;
#   src: https://github.com/wilkelab/gridtext
split.N.line = function(s, w=80, nL=NULL, indent = c("   ", "")) {
	# splits into nL lines!
	if(is.null(nL)) nL = 1 + ((nchar(s) - 1) %/% w);
	if(is.na(nL) || nL == 0) return(s);
	if(nL == 1) return(paste0(indent[1], s));
	nMax = nchar(s); n0 = 1; n = w; dn = w %/% 2;
	if(length(indent) == 1) indent = c(indent, "");
	#
	s2 = character(nL);
	for(id in seq(nL - 1)) {
		indent0 = if(id == 1) indent[1] else indent[2];
		# can split directly?
		if(n < nMax && substr(s, n+1, n+1) == " ") {
			s2[id] = paste0(indent0, substr(s, n0, n));
			n0 = n + 2; n = min(nMax, n0 + w); # skip next space;
			next;
		}
		# search a suitable split position:
		DO_NEXT = FALSE;
		for(npos in seq(n, n - dn)) {
			if(substr(s, npos, npos) %in% c(" ", "\n", ",", "-", ")")) {
				s2[id] = paste0(indent0, substr(s, n0, npos));
				n0 = npos + 1; n = min(nMax, n0 + w);
				DO_NEXT = TRUE;
				break;
			}
		}
		if(DO_NEXT) next;
		s2[id] = paste0(indent0, substr(s, n0, n));
		n0 = n + 1; n = min(nMax, n0 + w);
	}
	if(n0 <= nMax)
		s2[nL] = paste0(indent[2], substr(s, n0, nMax));
	return(s2);
}

### Helper Functions (Formatting)
nchar.L1.indent = function(s) {
	if(is.list(s)) sapply(s, function(ind) nchar(ind[[1]]))
	else if(is.matrix(s)) nchar(s[1,])
	else nchar(s[1]);
}
extract.L2.indent = function(s) {
	if(is.list(s)) lapply(s, function(ind) rep(ind[2], 2))
	else if(is.matrix(s)) s[c(2,2),]
	else if(length(s) > 1) c(s[2], s[2])
	else c(s, s);
}
rep.indent = function(s, len, other=3, default="") {
	if(is.list(s)) {
		len0 = length(s);
		if(len0 < len) {
			if(len0 == other) {
				default = s[[other]];
				if(is.list(default)) {
					default = unlist(default);
					s[[other]] = default; # for consistency
				}
			}
			default = list(default);
			s = c(s, rep(default, len - len0));
		}
		return(s);
	} else if(is.matrix(s)) {
		nc = ncol(s);
		if(nc < len) {
			if(nc == other) {
				default = s[,other];
			} else default = rep(default, nrow(s));
			s = cbind(s, rep(default, len - nc));
		}
		s = lapply(seq(nc), function(nc) s[,nc]);
		return(s);
	} else if(length(s) > 1) {
		len0 = length(s);
		if(len0 < len) {
			if(len0 == other) {
				default = s[other];
			} else if(len0 == 2) {
				# special Case: 1-st & next lines;
				return(matrix(s, nrow=2, ncol=len));
			}
			s = c(s, rep(default, len - len0));
		}
		return(s);
	} else {
		rep(s, len);
	}
	return(s);
}


### Other / UI / Display

cat.mlines = function(m, sep=" ", sep.h="-") {
	nc = ncol(m); m = t(m);
	sep = c(rep(sep, nc - 1), "\n");
	if(is.null(sep.h)) {
		cat(m, sep=sep);
	} else {
		# Note: m is transposed!
		len  = sum(nchar(m[,1]), na.rm=TRUE);
		len  = len + (nrow(m) - 1)*nchar(sep[[1]]);
		# Row-Separator
		part = if(nchar(sep.h) == 1) 0 else (len %% nchar(sep.h));
		chE  = if(part > 0) substr(sep.h, 1, part) else "";
		len  = len %/% nchar(sep.h);
		sep0 = paste0(c(rep(sep.h, len), chE), collapse="");
		nL   = attr(m, "nLines"); npos = cumsum(c(1, nL));
		sapply(seq(length(npos) - 1), function(nr) {
			cat(m[, seq(npos[nr], npos[nr+1] - 1), drop=F], sep=sep);
			cat(sep0, sep="\n");
		})
	}
	invisible()
}

### Text
# len = Number of records to show;
# w   = Width of columns;
scroll.txt = function(x, start=1, len=20, w = c(12, 6, 80, 16), iter=2,
		sep=" ", sep.h="-", print=TRUE, w.txt = c("   ", "")) {
	if(len < 1) return();
	len  = len - 1;
	# Column Lengths
	isMatrix  = ! is.null(dim(x));
	len.col   = if(isMatrix) ncol(x) else 1;
	len.other = if(len.col <= 3) 0 else len.col - 3;
	w = if(len.col == 2) w[c(1,3)]
		else if(len.col == 1) w[3]
		else if(len.other == 0) w[1:3]
		else if(length(w) == len.col) w
		else w[c(1,2, rep(w[3], len.other))];
	# Remove columns:
	idDel = which(w == 0);
	if(length(idDel) > 0) {
		x = x[, - idDel, drop = FALSE];
		w = w[- idDel];
	}
	# Indent
	indent = list(c(" ", "   "));
	if(len.col >= 3) indent = c(indent, list(" "));
	indent = c(indent, list(w.txt), rep(list(""), len.other));
	# Entries
	nr = if(isMatrix) nrow(x) else length(x);
	if(start > nr) stop("No more entries!");
	nend = min(nr, start + len);
	if(print) cat(c("Showing items ", start, " to ", nend, "."), sep=c(rep("", 4), "\n"));
	tmp.txt = if(isMatrix) x[seq(start, nend), ] else matrix(x[seq(start, nend)], ncol=1);
	cat.mlines(format.lines(tmp.txt, w=w, indent=indent, iter=iter),
		sep=sep, sep.h=sep.h);
}

