########################
###
### Leonard Mada
### [the one and only]
###
### Tools: Packages & CRAN
###
### draft v.0.1h



### Info about Packages

# - locally installed packages;

# Basic Info:
info.pkg = function(pkg=NULL, fields=c("Repository", "Description")) {
	if(is.null(pkg)) { pkg = installed.packages(fields=fields); }
	else {
		all.pkg = installed.packages();
		pkg = all.pkg[all.pkg[,1] %in% pkg, ];
	}
	p = pkg;
	p = as.data.frame(p);
	p = p[ , c("Package", "Version", "Built", fields, "Imports")];
	return(p);
}
# Imported packages:
imports.pkg = function(pkg=NULL, sort=TRUE) {
	p = info.pkg(pkg);
	### Imported packages
	imp = lapply(p$Imports, function(s) strsplit(s, "[,][ ]*"))
	imp = unlist(imp)
	imp = imp[ ! is.na(imp)]
	# Cleanup:
	imp = sub("[ \n\r\t]*+\\([-,. >=0-9\n\t\r]++\\) *+$", "", imp, perl=TRUE)
	imp = sub("^[ \n\r\t]++", "", imp, perl=TRUE);
	# Tabulate:
	tbl = as.data.frame(table(imp), stringsAsFactors=FALSE);
	names(tbl)[1] = "Name";
	if(sort) {
		id = order(tbl$Freq, decreasing=TRUE);
		tbl = tbl[id,];
	}
	return(tbl);
}

# Package Size:
size.f.pkg = function(path=NULL, exclude=NULL) {
	if(is.null(path)) path = R.home("library");
	xd = list.dirs(path = path, full.names = FALSE, recursive = FALSE);
	if( ! is.null(exclude)) {
		isExclude = grepl(exclude, xd);
		xd = xd[ ! isExclude];
	}
	size.f = function(p) {
		p = paste0(path, "/", p);
		sum(file.info(list.files(path=p, pattern=NULL,
			full.names = TRUE, all.files = TRUE, recursive = TRUE))$size);
	}
	sapply(xd, size.f);
}

size.pkg = function(path=NULL, sort=TRUE, file="Packages.Size.csv") {
	x = size.f.pkg(path=path);
	x = as.data.frame(x);
	names(x) = "Size"
	x$Name = rownames(x);
	# Order
	if(sort) {
		id = order(x$Size, decreasing=TRUE)
		x = x[id,];
	}
	if( ! is.null(file)) {
		if( ! is.character(file)) {
			print("Error: Size NOT written to file!");
		} else write.csv(x, file=file, row.names=FALSE);
	}
	return(x);
}

match.imports = function(pkg, x=NULL, quote=FALSE) {
	if(is.null(x)) x = info.pkg();
	if(quote) {
		pkg = paste0("\\Q", pkg, "\\E");
	}
	# TODO: Use word delimiters?
	# "(<?=^|[ \n\r\t],)"
	if(length(pkg) == 1) {
		isImport = grepl(pkg, x$Imports);
		return(x[isImport, ]);
	} else {
		# TODO: concept?
		rez = lapply(pkg, function(p) x[grepl(p, x$Imports), ]);
		return(rez);
	}
}

split.line = function(s, w=80, nL=NULL, indent = c("   ", "")) {
	if(is.null(nL)) nL = 1 + ((nchar(s) - 1) %/% w);
	if(is.na(nL) || nL == 0) return(s);
	if(nL == 1) return(paste0(indent[1], s));
	nMax = nchar(s); n0 = 1; n = w; dn = w %/% 2;
	if(length(indent) == 1) indent = c(indent, "");
	#
	s2 = character(nL);
	for(id in seq(nL - 1)) {
		DO_NEXT = FALSE;
		indent0 = if(id == 1) indent[1] else indent[2];
		for(npos in seq(n, n - dn)) {
			if(substr(s, npos, npos) %in% c(" ", "\n", ",", "-", ")")) {
				s2[id] = paste0(indent0, substr(s, n0, npos));
				n0 = npos + 1; n = min(nMax, n0 + w);
				DO_NEXT = TRUE;
				break;
			}
		}
		if(DO_NEXT) next;
		s2[id] = paste0(indent0, substr(s, n0, n));
		n0 = min(nMax, n + 1); n = min(nMax, n0 + w);
	}
	s2[nL] = paste0(indent[2], substr(s, n0, nMax));
	return(s2);
}
format.lines = function(x, w=80, justify="left", NL.rm=TRUE, indent=c("   ", ""), iter=2) {
	if(NL.rm) {
		for(nc in seq(ncol(x))) {
			x[, nc] = gsub("[ \t]*+\n++[ \t]*+", " ", x[, nc], perl=TRUE);
		}
	}
	# Detect Long Lines
	n  = sapply(seq(ncol(x)), function(nc) nchar(x[,nc]));
	nL = matrix(n, ncol=ncol(x));
	if(length(w) == 1) {
		nL = 1 + ((nL - 1) %/% w);
		w = rep(w, ncol(x));
	} else {
		nL = sapply(seq(ncol(x)), function(nc) 1 + ((nL[,nc] - 1) %/% w[nc]));
	}
	maxL = apply(nL, 1, max, na.rm=TRUE);
	nL[is.na(nL)] = 1;
	csm = cumsum(c(1, maxL));
	txt = matrix("", nrow=tail(csm, 1), ncol=ncol(x));
	for(nc in seq(ncol(x))) {
		indent0 = if(is.list(indent)) indent[[nc]] else indent;
		for(nr in seq(nrow(x))) {
			nL0 = nL[nr, nc];
			txt[seq(csm[nr], length.out=nL0), nc] =
				split.line(x[nr, nc], w=w[nc], nL=nL0, indent=indent0);
		}
	}
	# Better formatting: 2nd pass;
	if(iter >= 2) {
		indent0 = if(is.list(indent)) lapply(indent, function(ind) rep(ind[2], 2))
			else if(length(indent) > 1) c(indent[2], indent[2])
			else c(indent, indent);
		while(iter > 1) {
			iter = iter - 1;
			# re-format only last lines
			idLast = tail(csm, -1) - 1;
			idLast = idLast[maxL > 1]; # multiple lines
			txt = split.some.lines(txt, idLast, w=w, indent=indent0);
		}
	}
	return(apply(txt, 2, format, justify=justify));
}
# split only some of the lines: idL;
split.some.lines = function(txt, idL, w=80, indent="") {
	n = sapply(seq(ncol(txt)), function(nc) nchar(txt[idL, nc]));
	nL = matrix(n, ncol=ncol(txt));
	nL = sapply(seq(ncol(txt)), function(nc) 1 + ((nL[,nc] - 1) %/% w[nc]));
	nL = matrix(nL, ncol=ncol(txt));
	# Max No of Lines (generated by splitting):
	maxL = apply(nL, 1, max, na.rm=TRUE);
	isML = (maxL > 1);
	idL = idL[isML]; len = length(idL);
	if(len == 0) return(txt); # NO formatting needed;
	# filter out Lines to split:
	nL = nL[isML, , drop=FALSE]; maxL = maxL[isML];
	nL[is.na(nL)] = 0;
	if(ncol(txt) > 1 && length(indent) == 1) indent = rep(indent, len);
	dNRow = cumsum(maxL - 1);
	# idLine: Start & End
	idS = idL + c(0, head(dNRow, -1)); idE = idL + dNRow + 1;
	# Result:
	tmp = matrix("", nrow = nrow(txt) + tail(dNRow, 1), ncol=ncol(txt));
	# update matrix
	for(nc in seq(ncol(tmp))) {
		nr0 = 1; nr0_tmp = 1;
		for(idr in seq_along(idL)) {
			nr = idL[idr]; nr_tmp = idS[idr];
			if(nr > nr0) {
				tmp[seq(nr0_tmp, nr_tmp - 1), nc] = txt[seq(nr0, nr - 1), nc];
			}
			nL0 = nL[idr, nc];
			tmp[seq(nr_tmp, length.out = nL0), nc] =
				split.line(txt[nr, nc], w=w[nc], nL=nL0, indent=indent[[nc]]);
			nr0 = nr + 1; nr0_tmp = idE[idr];
		}
		if(nrow(tmp) >= nr0_tmp) {
			tmp[seq(nr0_tmp, nrow(tmp)), nc] = txt[seq(nr0, nrow(txt)), nc];
		}
	}
	return(tmp);
}

cat.mlines = function(m, sep=" ") {
	nc = ncol(m); m = t(m);
	cat(m, sep=c(rep(sep, nc - 1), "\n"));
}

scroll.pkg = function(pkg, start=0, len=15, w = c(12, 80, 16), iter=2) {
	if(len < 1) return();
	len  = len - 1;
	id = match(c("Package", "Description"), names(pkg));
	if(any(is.na(id))) stop("Package info must contain both the name & description!")
	pkg = cbind(pkg[, id], pkg[, - id]);
	# Column Lengths
	len.col = ncol(pkg); len.other = len.col - 2;
	w = if(len.other == 0) w[1:2]
		else if(length(w) == len.col) w
		else w[c(1,2, rep(w[3], len.other))];
	# Indent
	indent = c(list(c(" ", "   "), c("   ", "")), rep(list(""), len.other));
	# Entries
	if(start > nrow(pkg)) stop("No more entries!");
	nend = min(nrow(pkg), start + len);
	cat.mlines(format.lines(pkg[seq(start, nend), ], w=w, indent=indent, iter=iter));
}

find.pkg = function(s, pkg=NULL, perl=TRUE) {
	if(is.null(pkg)) pkg = info.pkg();
	isF = grepl(s, pkg$Description, perl=perl);
	pkg = pkg[isF, ];
	return(pkg);
}


###############
###############

### Package Size
# Note: takes ages!
if(FALSE) {
	# !! setwd(...); !!
	x = size.pkg();
}
if(FALSE) {
	system.time({
		x = size.pkg(file=NULL);
	})
	# elapsed time: 509 s !!!
	# 512 Packages; 1.64 GB;
}

x = read.csv("Packages.Size.csv")


### Imports
# - much faster: but NO size;
p = info.pkg();
f = imports.pkg();


#####################
### Data Analysis ###

### Size
head(x, 20)

### Description
# - packages which do NOT import any other package;
format.lines(p[is.na(p$Imports), ][1:20, -6])

# - pretty print:
cat.mlines(format.lines(p[is.na(p$Imports), c(1,5,2,3,4)][1:20, ]))

# - pretty print:
scroll.pkg(p[is.na(p$Imports), c(1,5,2,3,4)], start=30)


# - some are NOT Bioconductor packages;
# - TODO: filter by biocViews?
p[is.na(p$Repository), 1:4]


# No imports
table(is.na(p$Imports))
# Most imported
head(f, 20)

# imported only once:
f$Name[f$Freq == 1]


match.imports("hunspell", p)
match.imports("labeling", p)
match.imports("rpart.plot", p)

# Concept?
match.imports(c("pROC", "ROCR"), p)


###################

### Find in Package

p = info.pkg();

nrow(find.pkg("(?i)matrix", pkg=p))
scroll.pkg(find.pkg("(?i)matrix", pkg=p), start=1)

scroll.pkg(find.pkg("(?i)colou?+r", pkg=p), start=1)

scroll.pkg(find.pkg("(?i)dendro|phylo|tree", pkg=p), start=1)
scroll.pkg(find.pkg("(?i)dendro|phylo", pkg=p), start=1)

