########################
###
### Leonard Mada
### [the one and only]
###
### Tools: Packages & CRAN
###
### draft v.0.1n


###############
### History ###
###############


### draft v.0.1m - v.0.1n:
# - better word wrap;
# - more formatting options: cut(sep.h="-");
### draft v.0.1l - v.0.1l-fix:
# - more examples;
# - [fixed] crash with only 1 record;
### draft v.0.1k:
# - [minor] bug fix;
# - added more examples & comments;


#######################

### Info about Packages

# - locally installed packages;

# Basic Info:
info.pkg = function(pkg=NULL, fields=c("Repository", "Description")) {
	if(is.null(pkg)) { pkg = installed.packages(fields=fields); }
	else {
		all.pkg = installed.packages();
		pkg = all.pkg[all.pkg[,1] %in% pkg, ];
	}
	p = pkg;
	p = as.data.frame(p);
	p = p[ , c("Package", "Version", "Built", fields, "Imports")];
	return(p);
}
# Imported packages:
imports.pkg = function(pkg=NULL, sort=TRUE) {
	p = info.pkg(pkg);
	### Imported packages
	imp = lapply(p$Imports, function(s) strsplit(s, "[,][ ]*"))
	imp = unlist(imp)
	imp = imp[ ! is.na(imp)]
	# Cleanup:
	imp = sub("[ \n\r\t]*+\\([-,. >=0-9\n\t\r]++\\) *+$", "", imp, perl=TRUE)
	imp = sub("^[ \n\r\t]++", "", imp, perl=TRUE);
	# Tabulate:
	tbl = as.data.frame(table(imp), stringsAsFactors=FALSE);
	names(tbl)[1] = "Name";
	if(sort) {
		id = order(tbl$Freq, decreasing=TRUE);
		tbl = tbl[id,];
	}
	return(tbl);
}

# Package Size:
size.f.pkg = function(path=NULL, exclude=NULL) {
	if(is.null(path)) path = R.home("library");
	xd = list.dirs(path = path, full.names = FALSE, recursive = FALSE);
	if( ! is.null(exclude)) {
		isExclude = grepl(exclude, xd);
		xd = xd[ ! isExclude];
	}
	size.f = function(p) {
		p = paste0(path, "/", p);
		sum(file.info(list.files(path=p, pattern=NULL,
			full.names = TRUE, all.files = TRUE, recursive = TRUE))$size);
	}
	sapply(xd, size.f);
}

size.pkg = function(path=NULL, sort=TRUE, file="Packages.Size.csv") {
	x = size.f.pkg(path=path);
	x = as.data.frame(x);
	names(x) = "Size"
	x$Name = rownames(x);
	# Order
	if(sort) {
		id = order(x$Size, decreasing=TRUE)
		x = x[id,];
	}
	if( ! is.null(file)) {
		if( ! is.character(file)) {
			print("Error: Size NOT written to file!");
		} else write.csv(x, file=file, row.names=FALSE);
	}
	return(x);
}

match.imports = function(pkg, x=NULL, quote=FALSE) {
	if(is.null(x)) x = info.pkg();
	if(quote) {
		pkg = paste0("\\Q", pkg, "\\E");
	}
	# TODO: Use word delimiters?
	# "(<?=^|[ \n\r\t],)"
	if(length(pkg) == 1) {
		isImport = grepl(pkg, x$Imports);
		return(x[isImport, ]);
	} else {
		# TODO: concept?
		rez = lapply(pkg, function(p) x[grepl(p, x$Imports), ]);
		return(rez);
	}
}

##################
### Formatting ###

# Note:
# - a 1-pass exact algorithm is possible (and not too complicated),
#   but it requires sequential processing of each row;
format.lines = function(x, w=80, justify="left", NL.rm=TRUE, indent=c("   ", ""), iter=2) {
	if(NL.rm) {
		for(nc in seq(ncol(x))) {
			x[, nc] = gsub("[ \t]*+[\n\r]++[ \t\r]*+", " ", x[, nc], perl=TRUE);
		}
	}
	# Detect Long Lines
	n  = sapply(seq(ncol(x)), function(nc) nchar(x[,nc]));
	nL = matrix(n, ncol=ncol(x));
	# Indentation:
	indent = rep.indent(indent, ncol(x));
	addCh  = nchar.L1.indent(indent);
	nL = nL + addCh; # 1-st line gets always indented;
	if(length(w) == 1) {
		nL = 1 + ((nL - 1) %/% w);
		w = rep(w, ncol(x));
	} else {
		nL = sapply(seq(ncol(x)), function(nc) 1 + ((nL[,nc] - 1) %/% w[nc]));
	}
	if(is.null(dim(nL))) nL = matrix(nL, ncol=ncol(x));
	maxL = apply(nL, 1, max, na.rm=TRUE);
	nL[is.na(nL)] = 1;
	csm = cumsum(c(1, maxL));
	txt = matrix("", nrow=tail(csm, 1), ncol=ncol(x));
	for(nc in seq(ncol(x))) {
		indent0 = if(is.list(indent)) indent[[nc]] else indent;
		for(nr in seq(nrow(x))) {
			nL0 = nL[nr, nc];
			txt[seq(csm[nr], length.out=nL0), nc] =
				split.N.line(x[nr, nc], w=w[nc], nL=nL0, indent=indent0);
		}
	}
	# Better formatting: 2nd pass;
	if(iter >= 2) {
		indent0 = extract.L2.indent(indent);
		while(iter > 1) {
			iter = iter - 1;
			# re-format only last lines
			idLast  = tail(csm, -1) - 1; # ERR: fails for iter > 2
			idLast1 = idLast[maxL > 1]; # multiple lines
			txt = split.some.lines(txt, idLast1, w=w, indent=indent0);
			nL.new = attr(txt, "nLines");
			if( ! is.null(nL.new)) {
				id = match(nL.new[[1]], idLast);
				maxL[id] = maxL[id] + nL.new[[2]] - 1; # avoid double count;
			}
		}
	}
	txt = apply(txt, 2, format, justify=justify);
	attr(txt, "nLines") = maxL;
	return(txt);
}
# split only some of the lines: idL;
split.some.lines = function(txt, idL, w=80, indent="") {
	n = sapply(seq(ncol(txt)), function(nc) nchar(txt[idL, nc]));
	nL = matrix(n, ncol=ncol(txt));
	nL = sapply(seq(ncol(txt)), function(nc) 1 + ((nL[,nc] - 1) %/% w[nc]));
	nL = matrix(nL, ncol=ncol(txt));
	# Max No of Lines (generated by splitting):
	maxL = apply(nL, 1, max, na.rm=TRUE);
	isML = (maxL > 1);
	idL = idL[isML]; len = length(idL);
	if(len == 0) return(txt); # NO formatting needed;
	# filter out Lines to split:
	nL = nL[isML, , drop=FALSE]; maxL = maxL[isML];
	nL[is.na(nL)] = 0;
	if(ncol(txt) > 1 && length(indent) == 1) indent = rep(indent, len);
	dNRow = cumsum(maxL - 1);
	# idLine: Start & End
	idS = idL + c(0, head(dNRow, -1)); idE = idL + dNRow + 1;
	# Result:
	tmp = matrix("", nrow = nrow(txt) + tail(dNRow, 1), ncol=ncol(txt));
	# update matrix
	for(nc in seq(ncol(tmp))) {
		nr0 = 1; nr0_tmp = 1;
		for(idr in seq_along(idL)) {
			nr = idL[idr]; nr_tmp = idS[idr];
			if(nr > nr0) {
				tmp[seq(nr0_tmp, nr_tmp - 1), nc] = txt[seq(nr0, nr - 1), nc];
			}
			nL0 = nL[idr, nc];
			tmp[seq(nr_tmp, length.out = nL0), nc] =
				split.N.line(txt[nr, nc], w=w[nc], nL=nL0, indent=indent[[nc]]);
			nr0 = nr + 1; nr0_tmp = idE[idr];
		}
		if(nrow(tmp) >= nr0_tmp) {
			tmp[seq(nr0_tmp, nrow(tmp)), nc] = txt[seq(nr0, nrow(txt)), nc];
		}
	}
	attr(tmp, "nLines") = list(idL, maxL);
	return(tmp);
}

# TODO:
# - explore also package gridtext;
#   src: https://github.com/wilkelab/gridtext
split.N.line = function(s, w=80, nL=NULL, indent = c("   ", "")) {
	# splits into nL lines!
	if(is.null(nL)) nL = 1 + ((nchar(s) - 1) %/% w);
	if(is.na(nL) || nL == 0) return(s);
	if(nL == 1) return(paste0(indent[1], s));
	nMax = nchar(s); n0 = 1; n = w; dn = w %/% 2;
	if(length(indent) == 1) indent = c(indent, "");
	#
	s2 = character(nL);
	for(id in seq(nL - 1)) {
		indent0 = if(id == 1) indent[1] else indent[2];
		# can split directly?
		if(n < nMax && substr(s, n+1, n+1) == " ") {
			s2[id] = paste0(indent0, substr(s, n0, n));
			n0 = n + 2; n = min(nMax, n0 + w); # skip next space;
			next;
		}
		# search a suitable split position:
		DO_NEXT = FALSE;
		for(npos in seq(n, n - dn)) {
			if(substr(s, npos, npos) %in% c(" ", "\n", ",", "-", ")")) {
				s2[id] = paste0(indent0, substr(s, n0, npos));
				n0 = npos + 1; n = min(nMax, n0 + w);
				DO_NEXT = TRUE;
				break;
			}
		}
		if(DO_NEXT) next;
		s2[id] = paste0(indent0, substr(s, n0, n));
		n0 = n + 1; n = min(nMax, n0 + w);
	}
	if(n0 <= nMax)
		s2[nL] = paste0(indent[2], substr(s, n0, nMax));
	return(s2);
}

### Helper Functions (Formatting)
nchar.L1.indent = function(s) {
	if(is.list(s)) sapply(s, function(ind) nchar(ind[[1]]))
	else if(is.matrix(s)) nchar(s[1,])
	else nchar(s[1]);
}
extract.L2.indent = function(s) {
	if(is.list(s)) lapply(s, function(ind) rep(ind[2], 2))
	else if(is.matrix(s)) s[c(2,2),]
	else if(length(s) > 1) c(s[2], s[2])
	else c(s, s);
}
rep.indent = function(s, len, other=3, default="") {
	if(is.list(s)) {
		len0 = length(s);
		if(len0 < len) {
			if(len0 == other) {
				default = s[[other]];
				if(is.list(default)) {
					default = unlist(default);
					s[[other]] = default; # for consistency
				}
			}
			default = list(default);
			s = c(s, rep(default, len - len0));
		}
		return(s);
	} else if(is.matrix(s)) {
		nc = ncol(s);
		if(nc < len) {
			if(nc == other) {
				default = s[,other];
			} else default = rep(default, nrow(s));
			s = cbind(s, rep(default, len - nc));
		}
		s = lapply(seq(nc), function(nc) s[,nc]);
		return(s);
	} else if(length(s) > 1) {
		len0 = length(s);
		if(len0 < len) {
			if(len0 == other) {
				default = s[other];
			} else if(len0 == 2) {
				# special Case: 1-st & next lines;
				return(matrix(s, nrow=2, ncol=len));
			}
			s = c(s, rep(default, len - len0));
		}
		return(s);
	} else {
		rep(s, len);
	}
	return(s);
}


### Other / UI / Display

cat.mlines = function(m, sep=" ", sep.h="-") {
	nc = ncol(m); m = t(m);
	sep = c(rep(sep, nc - 1), "\n");
	if(is.null(sep.h)) {
		cat(m, sep=sep);
	} else {
		# Note: m is transposed!
		len  = sum(nchar(m[,1]), na.rm=TRUE);
		len  = len + (nrow(m) - 1)*length(sep.h);
		part = if(length(sep.h) == 1) 0 else len %% length(sep.h);
		len  = len %/% length(sep.h);
		sep0 = paste0(rep(sep.h, len), collapse="");
		nL   = attr(m, "nLines"); npos = cumsum(c(1, nL));
		sapply(seq(length(npos) - 1), function(nr) {
			cat(m[, seq(npos[nr], npos[nr+1] - 1), drop=F], sep=sep);
			cat(sep0, sep="\n");
		})
	}
	invisible()
}

scroll.pkg = function(pkg, start=1, len=15, w = c(12, 80, 16), iter=2, print=TRUE) {
	if(len < 1) return();
	len  = len - 1;
	id = match(c("Package", "Description"), names(pkg));
	if(any(is.na(id))) {
		if( ! inherits(pkg, "pkg_search_result"))
			stop("Package info must contain both the name & description!");
		pkg = extract.pkg(pkg, type="Basic");
		id = c(1, 2);
	}
	pkg = cbind(pkg[, id], pkg[, - id]);
	# Column Lengths
	len.col = ncol(pkg); len.other = len.col - 2;
	w = if(len.other == 0) w[1:2]
		else if(length(w) == len.col) w
		else w[c(1,2, rep(w[3], len.other))]; # TODO: if(w[4])
	# Indent
	indent = c(list(c(" ", "   "), c("   ", "")), rep(list(""), len.other));
	# Entries
	if(start > nrow(pkg)) stop("No more entries!");
	nend = min(nrow(pkg), start + len);
	if(print) cat(c("Showing packages ", start, " to ", nend, "."), sep=c(rep("", 4), "\n"))
	cat.mlines(format.lines(pkg[seq(start, nend), ], w=w, indent=indent, iter=iter));
}

extract.pkg = function(x, type="Basic", print=TRUE) {
	# TODO: type
	# ex: Title, Maintainer, Date/Publication, downloads
	pkg = lapply(x$package_data, function(x)
			data.frame(
				Package = x$Package, Description = x$Description,
				Version = x$Version, Repository = x$Repository));
	pkg = do.call(rbind, pkg);
	nTotal = attr(x, "metadata")$total;
	if(print) cat(c("Found ", nTotal, " packages."), sep=c(rep("", 2), "\n"))
	return(pkg);
}

find.pkg = function(s, pkg=NULL, print=TRUE, perl=TRUE) {
	if(is.null(pkg)) pkg = info.pkg();
	isF = grepl(s, pkg$Description, perl=perl);
	pkg = pkg[isF, , drop=FALSE];
	if(print) print(paste0("Found ", nrow(pkg), " packages."))
	return(pkg);
}


################
################

### Package Size
# Note: takes ages!
if(FALSE) {
	# !! setwd(...); !!
	x = size.pkg();
}
if(FALSE) {
	system.time({
		x = size.pkg(file=NULL);
	})
	# elapsed time: 509 s !!!
	# 512 Packages; 1.64 GB;
}

# using previously saved data:
xsz = read.csv("Packages.Size.csv")


### Imports
# - much faster: but NO size;
p = info.pkg();
f = imports.pkg();


#####################
### Data Analysis ###

### Size
head(xsz, 20)


### Description
# - packages which do NOT import any other package;
format.lines(p[is.na(p$Imports), ][1:20, -6])

# - pretty print:
cat.mlines(format.lines(p[is.na(p$Imports), c(1,5,2,3,4)][1:20, ]))

# - pretty print:
scroll.pkg(p[is.na(p$Imports), c(1,5,2,3,4)], start=30)


### Exploratory analysis

# - some are NOT Bioconductor packages;
# - TODO: filter by biocViews?
p[is.na(p$Repository), 1:4]


# No imports
table(is.na(p$Imports))
# Most imported
head(f, 20)

# imported only once:
f$Name[f$Freq == 1]


match.imports("hunspell", p)
match.imports("labeling", p)
match.imports("rpart.plot", p)

# Concept?
match.imports(c("pROC", "ROCR"), p)


###################

### Find in Package

p = info.pkg();

nrow(find.pkg("(?i)matrix", pkg=p))
scroll.pkg(find.pkg("(?i)matrix", pkg=p), start=1)

scroll.pkg(find.pkg("(?i)colou?+r", pkg=p), start=1)

scroll.pkg(find.pkg("(?i)dendro|phylo|tree", pkg=p), start=1)
scroll.pkg(find.pkg("(?i)dendro|phylo", pkg=p), start=1)


###############

### Search CRAN
library(pkgsearch)


# only simple expressions are possible:
searchCran = function(s, from=1, len=60, len.print=20, extend="*") {
	if( ! is.null(extend)) s = paste0(s, extend);
	x = advanced_search(s, size=len, from=from);
	if(length(x$package_data) == 0) {
		cat("No packages found!", sep="\n");
	} else {
		scroll.pkg(x, len=len.print);
	}
	invisible(x)
}

### Examples:

### Text-Processing

x = searchCran("text", from=60)

scroll.pkg(x, start=20, len=21)


### Other packages
# TODO: explore;
# - sources: pubmed.mineR, rplos, rbhl (biodiversity), rcoreoa;
# - tools: diffr, cheatR,
#   LDAShiny, corporaexplorer, tokenizers.bpe, text;
# - output: ..., grobblR, REPLesentR, rdoc;
# - other search words:
#   mining, language, NLP, LDA, phrase, content, corpora,
#   wordcloud, bibliometric;


###############

### Dendrograms
x = searchCran("dendro")

scroll.pkg(x, start=20, len=21)


### PDB
x = searchCran("pdb")

scroll.pkg(x, start=20, len=21)


### Img Processing
x = searchCran("texture")

scroll.pkg(x, start=20, len=21)


### ...
# invasion/invasive, intruder, speciation
x = searchCran("intruder")

scroll.pkg(x, start=20, len=21)


### Percolation
# percol, pore, poros/porou, adsorb
x = searchCran("pore")

scroll.pkg(x, start=20, len=21)

